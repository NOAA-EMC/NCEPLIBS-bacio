/** @file
 * @brief Fortran-callable routines to read and write characther
 * data byte addressably.
 *
 *  v1.1:
 * - Put diagnostic output under control of define VERBOSE or QUIET
 * - Add option of non-seeking read/write
 * - Return code for fewer data read/written than requested
 *
 *  v1.2:
 * - Add cray compatibility  20 April 1998  Robert Grumbine
 *
 *  v1.3:
 * - Add IBMSP compatibility (IBM4, IBM8)
 * - Add modes BAOPEN_WONLY_TRUNC, BAOPEN_WONLY_APPEND
 * - Use isgraph instead of isalnum + a short list of accepted characters
 * for filename check 12 Dec 2000 Stephen Gilbert
 * - negative return codes are wrapped to positive, revise return codes
 * verify that banio and bacio have same contents, update comments
 * 29 Oct 2008 Robert Grumbine
 *
 *  v1.4:
 * - 21 Nov 2008 Add baciol and baniol functions, versions to work with files
 * over 2 Gb Robert Grumbine
 * - Aug 2012 Jun Wang fix c filename length because the c string
 * needs to end with "null" terminator , and free allocated cfile
 * name realname to avoid memory leak.
 * - Sep 2012 Jun Wang: remove execute permission on the data file
 * generated by bacio.
 *
 * @author Robert Grumbine @date 16 March 1998
 */

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

#include "clib.h"

/**
 * Do bacio operation, with new names for long int arguments, needed
 * for files > 2 Gb.
 *
 * @param mode integer specifying operations to be performed see the
 * clib.inc file for the values. Mode is obtained by adding together
 * the values corresponding to the operations The best method is to
 * include the clib.inc file and refer to the names for the operations
 * rather than rely on hard-coded values.
 * @param start byte number to start your operation from. 0 is the
 * first byte in the file, not 1.
 * @param newpos position in the file after a read or write has been
 * performed. You'll need this if you're doing 'seeking' read/write.
 * @param size is the size of the objects you are trying to read. Rely
 * on the values in the locale.inc file. Types are CHARACTER, INTEGER,
 * REAL, COMPLEX. Specify the correct value by using SIZEOF_type,
 * where type is one of these. (After having included the locale.inc
 * file).
 * @param no is the number of things to read or write (characters,
 * integers, whatever).
 * @param nactual is the number of things actually read or
 * written. Check that you got what you wanted.
 * @param fdes is an integer 'file descriptor'. This is not a Fortran
 * Unit Number You can use it, however, to refer to files you've
 * previously opened.
 * @param fname is the name of the file. This only needs to be defined
 * when you are opening a file. It must be (on the Fortran side)
 * declared as CHARACTER*N, where N is a length greater than or equal
 * to the length of the file name. CHARACTER*1 fname[80] (for example)
 * will fail.
 * @param datary is the name of the entity (variable, vector, array)
 * that you want to write data out from or read it in to. The fact
 * that C is declaring it to be a char * does not affect your fortran.
 * @param namelen - Do NOT specify this. It is created automagically by the
 * Fortran compiler
 * @param datanamelen - Do NOT specify this. It is created automagically by the
 * Fortran compiler
 *
 * @note In your Fortran code, call bacio(), not bacio_().
 *
 * What is going on here is that although the Fortran caller will
 * always be calling bacio, the called C routine name will change from
 * system to system.
 *
 * @return 0 All was well
 * @return 255 Tried to open read only _and_ write only
 * @return 254 Tried to read and write in the same call
 * @return 253 Internal failure in name processing
 * @return 252 Failure in opening file
 * @return 251 Tried to read on a write-only file
 * @return 250 Failed in read to find the 'start' location
 * @return 249 Tried to write to a read only file
 * @return 248 Failed in write to find the 'start' location
 * @return 247 Error in close
 * @return 246 Read or wrote fewer data than requested
 * @return 102 Massive catastrophe -- datary pointer is NULL
 *
 * @author Robert Grumbine @date 21 November 2008
 */
int
baciol_(int *mode, long int *start, long int *newpos, int *size, long int *no,
        long int *nactual, int *fdes, const char *fname, char *datary,
        int namelen, int datanamelen)
{
    int i, jret, seekret;
    char *realname;
    size_t count;

    /* Initialization(s) */
    *nactual = 0;

    /* Check for illegal combinations of options */
    if ((BAOPEN_RONLY & *mode) &&
        ((BAOPEN_WONLY & *mode) || (BAOPEN_WONLY_TRUNC & *mode) || (BAOPEN_WONLY_APPEND & *mode)))
        return 255;

    if ((BAREAD & *mode) && (BAWRITE & *mode)) 
        return 254;

    /* This section handles Fortran to C translation of strings so as
     * to be able to open the files Fortran is expecting to be
     * opened. */
    if ((BAOPEN_RONLY & *mode) || (BAOPEN_WONLY & *mode) ||
        (BAOPEN_WONLY_TRUNC & *mode) || (BAOPEN_WONLY_APPEND & *mode) ||
        (BAOPEN_RW & *mode))
    {
        if (!(realname = (char *) malloc((namelen + 1) * sizeof(char))))
            return 253;

        i=0;
        while (i < namelen && isgraph(fname[i])) {
            realname[i]=fname[i];
            i++;
        }
        realname[i] = '\0';

    }

    /* Open files with correct read/write and file permission. */
    if (BAOPEN_RONLY & *mode)
    {
        *fdes = open(realname, O_RDONLY , S_IRUSR | S_IRGRP | S_IROTH | S_IWUSR | S_IWGRP);
    }
    else if (BAOPEN_WONLY & *mode)
    {
        *fdes = open(realname, O_WRONLY | O_CREAT , S_IRUSR | S_IRGRP | S_IROTH | S_IWUSR | S_IWGRP);
    }
    else if (BAOPEN_WONLY_TRUNC & *mode)
    {
        *fdes = open(realname, O_WRONLY | O_CREAT | O_TRUNC , S_IRUSR | S_IRGRP | S_IROTH | S_IWUSR | S_IWGRP);
    }
    else if (BAOPEN_WONLY_APPEND & *mode)
    {
        *fdes = open(realname, O_WRONLY | O_CREAT | O_APPEND , S_IRUSR | S_IRGRP | S_IROTH | S_IWUSR | S_IWGRP);
    }
    else if (BAOPEN_RW & *mode)
    {
        *fdes = open(realname, O_RDWR | O_CREAT , S_IRUSR | S_IRGRP | S_IROTH | S_IWUSR | S_IWGRP);
    }

    if (*fdes < 0) 
        return 252;

    /* Read data as requested */
    if (BAREAD & *mode &&
        ((BAOPEN_WONLY & *mode) || (BAOPEN_WONLY_TRUNC & *mode) || (BAOPEN_WONLY_APPEND & *mode)))
        return 251;
    else if (BAREAD & *mode )
    {
        /* Read in some data */
        if (!(*mode & NOSEEK))
        {
            seekret = lseek(*fdes, *start, SEEK_SET);
            if (seekret == -1)
                return 250;
        }

        if (datary == NULL)
        {
            printf("Massive catastrophe -- datary pointer is NULL\n");
            return 102;
        }
        count = (size_t) *no;
        jret = read(*fdes, (void *) datary, count);
        *nactual = jret;
        *newpos = *start + jret;
    }
    /* Done with reading */

    /* See if we should be writing */
    if (BAWRITE & *mode && BAOPEN_RONLY & *mode) 
        return 249;
    else if (BAWRITE & *mode)
    {
        if (!(*mode & NOSEEK))
        {
            seekret = lseek(*fdes, *start, SEEK_SET);
            if (seekret == -1) 
                return 248;
        }
        if (datary == NULL)
        {
            printf("Massive catastrophe -- datary pointer is NULL\n");
            return 102;
        }
        count = (size_t)*no;
        jret = write(*fdes, (void *) datary, count);
        if (jret != *no)
        {
            *nactual = jret;
            *newpos = *start + jret;
        }
        else
        {
            *nactual = jret;
            *newpos = *start + jret;
        }
    }
    /* Done with writing */

    /* Close file if requested */
    if (BACLOSE & *mode )
    {
        jret = close(*fdes);
        if (jret != 0)
            return 247;
    }
    /* Done closing */

    /* Free the realname pointer to prevent memory leak */
    if ((BAOPEN_RONLY & *mode) || (BAOPEN_WONLY & *mode) ||
         (BAOPEN_WONLY_TRUNC & *mode) || (BAOPEN_WONLY_APPEND & *mode) ||
         (BAOPEN_RW & *mode))
    {
        free(realname);
    }

    /* Check that if we were reading or writing, that we actually got
       what we expected, else return a -10. Return 0 (success) if we're
       here and weren't reading or writing. */
    if ((*mode & BAREAD || *mode & BAWRITE) && (*nactual != *no))
        return 246;
    else 
        return 0;
}

/**
 * Do bacio operation.
 *
 * @param mode integer specifying operations to be performed see the
 * clib.inc file for the values. Mode is obtained by adding together
 * the values corresponding to the operations The best method is to
 * include the clib.inc file and refer to the names for the operations
 * rather than rely on hard-coded values.
 * @param start byte number to start your operation from. 0 is the
 * first byte in the file, not 1.
 * @param newpos position in the file after a read or write has been
 * performed. You'll need this if you're doing 'seeking' read/write.
 * @param size is the size of the objects you are trying to
 * read. Types are CHARACTER, INTEGER, REAL, COMPLEX.
 * @param no is the number of things to read or write (characters,
 * integers, whatever).
 * @param nactual is the number of things actually read or
 * written. Check that you got what you wanted.
 * @param fdes is an integer 'file descriptor'. This is not a Fortran
 * Unit Number You can use it, however, to refer to files you've
 * previously opened.
 * @param fname is the name of the file. This only needs to be defined
 * when you are opening a file. It must be (on the Fortran side)
 * declared as CHARACTER*N, where N is a length greater than or equal
 * to the length of the file name. CHARACTER*1 fname[80] (for example)
 * will fail.
 * @param datary is the name of the entity (variable, vector, array)
 * that you want to write data out from or read it in to. The fact
 * that C is declaring it to be a char * does not affect your fortran.
 * @param namelen - Do NOT specify this. It is created automagically by the
 * Fortran compiler
 * @param datanamelen - Do NOT specify this. It is created automagically by the
 * Fortran compiler
 *
 * @note In your Fortran code, call bacio(), not bacio_().
 *
 * What is going on here is that although the Fortran caller will
 * always be calling bacio, the called C routine name will change from
 * system to system.
 *
 * @return 0 All was well
 * @return 255 Tried to open read only _and_ write only
 * @return 254 Tried to read and write in the same call
 * @return 253 Internal failure in name processing
 * @return 252 Failure in opening file
 * @return 251 Tried to read on a write-only file
 * @return 250 Failed in read to find the 'start' location
 * @return 249 Tried to write to a read only file
 * @return 248 Failed in write to find the 'start' location
 * @return 247 Error in close
 * @return 246 Read or wrote fewer data than requested
 * @return 102 Massive catastrophe -- datary pointer is NULL
 *
 * @author Robert Grumbine @date 16 March 1998
 */
int
bacio_(int *mode, int *start, int *newpos, int *size, int *no,
       int *nactual, int *fdes, const char *fname, char *datary,
       int namelen, int datanamelen)
{
    long int lstart;
    long int lnewpos;
    long int lno;
    long int lnactual;
    int ret;

    lstart = *start;
    lnewpos = *newpos;
    lno = *no;

    /* Call the version of this function with long int parameters. */
    ret = baciol_(mode, &lstart, &lnewpos, size, &lno, &lnactual, fdes,
                  fname, datary, namelen, datanamelen);

    *nactual = lnactual;

    return ret;
}
